import idautils
import idaapi
import ida_ua
import idc

class myplugin_t(idaapi.plugin_t):
    flags = idaapi.PLUGIN_UNL
    comment = "This is a comment"
    help = "This is help"
    wanted_name = "Diagraph Dataflow Files"
    wanted_hotkey = "Alt-F8"

    def init(self):
        return idaapi.PLUGIN_OK

    def run(self, arg):
        for ea in idautils.Functions():
            dot = DiagraphDataflow(ea) # initialize class
            #print(dot.node_buffer, dot.path_buffer) # print
            dot.write_to_file() # write to file

    def term(self):
        pass

def PLUGIN_ENTRY():
    return myplugin_t()

class Instruction:
    def __init__(self, ea, end_ea):
        self.ea = ea # instruction memory address
        self.end_ea = end_ea # function end address
        if self.ea >= self.end_ea or self.ea == idc.BADADDR:
            self.ea = idc.BADADDR
            return
        self.insn = ida_ua.insn_t() # insn_t Class
        idaapi.decode_insn(self.insn, self.ea) # load instruction to insn_t class
        self.name = self.insn.get_canon_mnem() # instruction name
        self.op1 = idc.print_operand(ea, 0) # operand 1 string
        self.op2 = idc.print_operand(ea, 1) # operand 2 string
        self.op3 = idc.print_operand(ea, 2) # operand 3 string
        self.next_ea = list()
        self.__get_next_ea()
        self.define = set()
        self.use = set()
        self.define_dict = dict()
        self.stack = list()
        self.stkargs = 0
        self.__get_DUchain() # get DU chain
        
    def get_next_ea(self):
        """Get next instruction addresses
        """
        next_ea = idaapi.next_head(self.ea, self.end_ea)
        if next_ea < self.end_ea and next_ea != idc.BADADDR:
            if self.name[0] == 'j':
                if self.name == 'jmp':
                    si = idaapi.switch_info_t()
                    if idaapi.get_switch_info(si, self.insn.Op1.addr): # switch case
                        results = idaapi.calc_switch_cases(self.insn.Op1.addr, si)
                        for idx in range(results.cases.size()):
                            self.next_ea.append(results.targets[idx])

                    else: # regular jump
                        self.next_ea.append(self.insn.Op1.addr)
                else:
                    self.next_ea.append(next_ea)
                    self.next_ea.append(self.insn.Op1.addr)

            else:
                self.next_ea.append(next_ea)
    __get_next_ea = get_next_ea
    
    def get_base_operand(self, op_name):
        
        temp = op_name[op_name.find('[')+1:]
        temp = temp.replace('[', '')
        temp = temp.replace(']', '')
        temp = temp.split('+')
        return temp[0]
    __get_base_operand = get_base_operand
    
    def uint_to_int(self, num):
        if num > 2 ** 31 - 1:
            return num - (2 ** 32)
        else:
            return num
    __uint_to_int = uint_to_int
    
    def get_DUchain(self):
        """Assign define and use values from DU chain
        """
        unary_op = ['inc', 'dec']
        binary_op = ['add', 'sub', 'imul', 'xor', 'or', 'and']
        shift_op = ['sar', 'shr']
        addr_type = [ida_ua.o_mem, ida_ua.o_far, ida_ua.o_near]
        
        # push
        if self.name == 'push':
            self.define.add('esp')
            self.use.add('esp')
            if self.insn.Op1.type == ida_ua.o_reg:
                self.use.add(self.op1)
            elif self.insn.Op1.type == ida_ua.o_displ:
                self.use.add(self.__get_base_operand(self.op1))
            elif self.insn.Op1.type == ida_ua.o_phrase:
                self.use.add(self.__get_base_operand(self.op1))
                self.use.add('[{}]'.format(self.__get_base_operand(self.op1)))
            elif self.insn.Op1.type in addr_type:
                self.use.add('[{}]'.format(hex(self.__uint_to_int(self.insn.Op1.addr))))
            elif self.insn.Op1.type in addr_type:
                if self.op1[:3] == 'lar':
                    self.use.add('FS:[{}]'.format(hex(self.insn.Op2.addr)), 'FS_OFFSET')
                else:
                    self.use.add('[{}]'.format(hex(self.insn.Op1.addr)))
            else:    
                pass
        # pop
        elif self.name == 'pop':
            self.define.add('esp')
            if self.insn.Op1.type == ida_ua.o_reg:
                self.define.add(self.op1)
            elif self.insn.Op1.type == ida_ua.o_displ:
                self.define.add('[{} + {}]'.format(self.__get_base_operand(self.op1), hex(self.__uint_to_int(self.insn.Op1.addr))))
            elif self.insn.Op1.type == ida_ua.o_phrase:
                self.use.add(self.__get_base_operand(self.op1))
                self.define.add('[{}]'.format(self.__get_base_operand(self.op1)))
            elif self.insn.Op1.type in addr_type:
                if self.op1[:3] == 'lar':
                    self.define.add('FS:[{}]'.format(hex(self.insn.Op1.addr)))
                    self.use.add('FS_OFFSET')
                else:
                    self.define.add('[{}]'.format(hex(self.insn.Op1.addr)))
            else:
                pass
            self.use.add('esp')
        
        # call
        if self.name == 'call':
            tif = idaapi.tinfo_t()
            if (idaapi.get_tinfo(tif, self.insn.Op1.addr)): # get_tinfo successful
                funcdata = idaapi.func_type_data_t()
                if (tif.is_funcptr()):
                    real_tif = tif.get_pointed_object()
                    real_tif.get_func_details(funcdata)
                else:
                    tif.get_func_details(funcdata)
        
                if str(funcdata.rettype) != 'void': # function has return value
                    self.define.add('eax')
                
                self.stkargs = funcdata.stkargs

            else: # get_tinfo failed
                func = idaapi.get_func(self.insn.Op1.addr)
                if func == None:
                    pass # __getmainarge function is not recognized by idapro. manually add function to the plugin
                         # __getmainarge function addr: 0x4030c0
                else:
                    pass # all functions have 0 input arguments

        
        # leave
        elif self.name == 'leave':
            self.define.update(['ebp', 'esp'])
            self.use.update(['ebp', 'esp'])
        
        # ret
        elif self.name == 'ret':
            self.use.add('esp')
        
        # mov, lea
        elif self.name[:2] == 'mo' or self.name == 'lea':
            if self.insn.Op1.type == ida_ua.o_reg:
                self.define.add(self.op1)
            elif self.insn.Op1.type == ida_ua.o_displ:
                self.define.add('[{} + {}]'.format(self.__get_base_operand(self.op1), hex(self.__uint_to_int(self.insn.Op1.addr))))
                self.use.add(self.__get_base_operand(self.op1))
            elif self.insn.Op1.type == ida_ua.o_phrase:
                self.define.add(self.op1)
                self.use.add(self.__get_base_operand(self.op1))
            elif self.insn.Op1.type in addr_type:
                if self.op1[:3] == 'lar':
                    self.define.add('FS:[{}]'.format(hex(self.insn.Op1.addr)))
                    self.use.add('FS_OFFSET')
                else:
                    self.define.add('[{}]'.format(hex(self.insn.Op1.addr)))
            else:
                pass
            
            if self.insn.Op2.type == ida_ua.o_reg:
                self.use.add(self.op2)
            elif self.insn.Op2.type == ida_ua.o_displ:
                if self.name[:2] == 'mo':
                    self.use.add('[{} + {}]'.format(self.__get_base_operand(self.op2), hex(self.__uint_to_int(self.insn.Op2.addr))))
                self.use.add(self.__get_base_operand(self.op2))
            elif self.insn.Op2.type == ida_ua.o_phrase:
                self.use.update([self.op2, self.__get_base_operand(self.op2)]) if self.name[:2] == 'mo' else self.use.add(self.op2)
            elif self.insn.Op2.type in addr_type:
                if self.op2[:3] == 'lar':
                    self.use.update(['FS:[{}]'.format(hex(self.insn.Op2.addr)), 'FS_OFFSET'])
                else:
                    self.use.add('[{}]'.format(hex(self.insn.Op2.addr)))
            else:
                pass
                
        # cmp, test
        elif self.name == 'cmp' or self.name == 'test':
            self.define.update(['CF', 'ZF', 'SF', 'OF'])
            if self.insn.Op1.type == ida_ua.o_reg:
                self.use.add(self.op1)
            elif self.insn.Op1.type == ida_ua.o_displ:
                self.use.add(self.__get_base_operand(self.op1))
                self.use.add('[{} + {}]'.format(self.__get_base_operand(self.op1), hex(self.__uint_to_int(self.insn.Op1.addr))))
            elif self.insn.Op1.type == ida_ua.o_phrase:
                self.use.update(['[{}]'.format(self.__get_base_operand(self.op1)), self.__get_base_operand(self.op1)])
            elif self.insn.Op1.type in addr_type:
                if self.op1[:3] == 'lar':
                    self.use.add('FS:[{}]'.format(hex(self.insn.Op1.addr)))
                    self.use.add('FS_OFFSET')
                else:
                    self.use.add('[{}]'.format(hex(self.insn.Op1.addr)))
            else:
                pass
            
            if self.insn.Op2.type == ida_ua.o_reg:
                self.use.add(self.op2)
            elif self.insn.Op2.type == ida_ua.o_displ:
                self.use.add(self.__get_base_operand(self.op2))
                self.use.add('[{} + {}]'.format(self.__get_base_operand(self.op1), hex(self.__uint_to_int(self.insn.Op1.addr))))
            elif self.insn.Op2.type == ida_ua.o_phrase:
                self.use.update(['[{}]'.format(self.__get_base_operand(self.op2)), self.__get_base_operand(self.op2)])
            elif self.insn.Op2.type in addr_type:
                if self.op2[:3] == 'lar':
                    self.use.update(['FS:[{}]'.format(hex(self.insn.Op2.addr)), 'FS_OFFSET'])
                else:
                    self.use.add('[{}]'.format(hex(self.insn.Op2.addr)))
            else:
                pass
                
        # jump operators
        elif self.name[0] == 'j':
            if self.name in ['jz', 'je', 'jnz']:
                self.use.add('ZF')
            elif self.name in ['jle', 'jg']:
                self.use.update(['ZF', 'SF', 'OF'])
            elif self.name in ['ja', 'jbe']:
                self.use.update(['CF', 'ZF'])
            elif self.name in ['jnb', 'jb']:
                self.use.add('CF')
            elif self.name == 'jl':
                self.use.update(['SF', 'OF'])
            else:
                pass
                         
                
        # binary, unary, shift operators
        elif self.name in binary_op + unary_op + shift_op:
            if self.name in binary_op:
                self.define.update(['CF', 'ZF', 'SF', 'OF'])
            elif self.name in unary_op:
                self.define.update(['ZF', 'SF', 'OF'])
            if self.insn.Op1.type == ida_ua.o_reg:
                self.define.add(self.op1)
                self.use.add(self.op1)
            elif self.insn.Op1.type == ida_ua.o_displ:
                self.define.add('[{} + {}]'.format(self.__get_base_operand(self.op1), hex(self.__uint_to_int(self.insn.Op1.addr))))
                self.use.add(self.__get_base_operand(self.op1))
                self.use.add('[{} + {}]'.format(self.__get_base_operand(self.op1), hex(self.__uint_to_int(self.insn.Op1.addr))))
            elif self.insn.Op1.type == ida_ua.o_phrase:
                self.define.add('[{}]'.format(self.__get_base_operand(self.op1)))
                self.use.add(self.__get_base_operand(self.op1))
                self.use.add('[{}]'.format(self.__get_base_operand(self.op1)))
            elif self.insn.Op1.type in addr_type:
                if self.op1[:3] == 'lar':
                    self.define.add('FS:[{}]'.format(hex(self.insn.Op1.addr)))
                    self.use.update(['FS:[{}]'.format(hex(self.insn.Op2.addr)), 'FS_OFFSET'])
                else:
                    self.define.add('[{}]'.format(hex(self.insn.Op1.addr)))
                    self.use.add('[{}]'.format(hex(self.insn.Op1.addr)))
            else:
                pass
            
            if self.insn.Op2.type == ida_ua.o_reg:
                self.use.add(self.op2)
            elif self.insn.Op2.type == ida_ua.o_displ:
                self.use.add(self.__get_base_operand(self.op2))
                self.use.add('[{} + {}]'.format(self.__get_base_operand(self.op2), hex(self.__uint_to_int(self.insn.Op2.addr))))
            elif self.insn.Op2.type == ida_ua.o_phrase:
                self.use.update(['[{}]'.format(self.__get_base_operand(self.op2)), self.__get_base_operand(self.op2)])
            elif self.insn.Op2.type in addr_type:
                if self.op2[:3] == 'lar':
                    self.use.update(['FS:[{}]'.format(hex(self.insn.Op2.addr)), 'FS_OFFSET'])
                else:
                    self.use.add('[{}]'.format(hex(self.insn.Op2.addr)))
            else:
                pass
            
        # setnz operators
        elif self.name == 'setnz':
            if self.insn.Op1.type == ida_ua.o_reg:
                self.define.add(self.op1)
            elif self.insn.Op1.type == ida_ua.o_displ:
                self.use.add(self.__get_base_operand(self.op1))
                self.define.add('[{} + {}]'.format(self.__get_base_operand(self.op1), hex(self.__uint_to_int(self.insn.Op1.addr))))
            elif self.insn.Op1.type == ida_ua.o_phrase:
                self.use.add(self.__get_base_operand(self.op1))
                self.define.add('[{}]'.format(self.__get_base_operand(self.op1)))
            elif self.insn.Op1.type in addr_type:
                if self.op1[:3] == 'lar':
                    self.define.add('FS:[{}]'.format(hex(self.insn.Op1.addr)))
                    self.use.add('FS_OFFSET')
                else:
                    self.define.add('[{}]'.format(hex(self.insn.Op1.addr)))
            self.use.add('ZF')
            
        # stos operator
        elif self.name == 'stos':
            if self.insn.Op1.dtype == ida_ua.dt_byte:
                self.define.add('di')
                self.use.add('al')
            elif self.insn.Op1.dtype == ida_ua.dt_word:
                self.define.add('edi')
                self.use.add('ax')
            elif self.insn.Op1.dtype == ida_ua.dt_dword:
                self.define.add('edi')
                self.use.add('eax')
            else:
                pass            
        else:
            pass               
    __get_DUchain = get_DUchain
    
class DiagraphDataflow:
    def __init__(self, ea):
        self.ea = ea
        #self.stack = list()
        self.func = idaapi.get_func(self.ea)
        self.end_ea = self.func.end_ea
        self.node_buffer = 'digraph data_flow {\n'
        self.path_buffer = ''
        self.node_dict = self.__create_node_dict()
        #self.define_dict = {'esp':{'START'}}
        #self.path_dict = {0:[list(), list()]}
        #self.path_dict_idx = 0
        #self.path_loop_detect = set()
        #self.__get_paths(0, Instruction(self.ea, self.end_ea))
        self.node_arr = dict()
        self.__set_node_array()
        self.__append_nodes()
        self.path_buffer += '}\n'
    
    def write_to_file(self):
        with open(str(hex(self.ea)) + '.dot', "w") as f:
            f.write(self.node_buffer)
            f.write('\n')
            f.write(self.path_buffer)
    
    def create_node_dict(self):
        """
        Create Node Dictionary
        Format: {ea: [idx, DD addr(s)]}
        """
        Dict = dict()
        Dict['START'] = [0, set()]
        idx = 1
        for item in idautils.FuncItems(self.ea):
            Dict[item] = [idx, set()]
            idx += 1
        return Dict
    __create_node_dict = create_node_dict     

    def set_node_array(self):
        
        # set node_arr
        for ea in idautils.FuncItems(self.ea):
            self.node_arr[ea] = Instruction(ea, self.end_ea)
        
        for key, instr in self.node_arr.items():
            if instr.name == 'push':
                instr.stack.append([instr.ea, ida_ua.get_dtype_size(instr.insn.Op1.dtype)]) # [ea, size of operand]
                
                #instr.define.add('[esp]')
            elif instr.name == 'pop':
                if instr.stack != list():
                    instr.stack.pop()
            elif instr.name == 'call':
                if hex(instr.insn.Op1.addr) == '0x4030c0':
                    # edge case the function not recognized by the idapython
                    # __getmainargs gets 5 input arguments
                    self.node_dict[instr.ea][1].add('START')
                    for idx in range(5):
                        if instr.stack != list():
                            temp = instr.stack.pop()
                            self.node_dict[instr.ea][1].add(temp[0])
                else:
                    if instr.op1[:2] == 'ds':
                        self.node_dict[instr.ea][1].add('START')
                    
                    while instr.stkargs > 0:    
                        if instr.stack != list():
                            temp = instr.stack.pop()
                            self.node_dict[instr.ea][1].add(temp[0])
                            instr.stkargs -= temp[1]
            
            # update node_dict
            for item in instr.use:
                if instr.define_dict.get(item) == None: # use element is not defined
                    self.node_dict[instr.ea][1].add('START')
                else:
                    self.node_dict[instr.ea][1].update(instr.define_dict[item])
                    
            # update define_dict
            for item in instr.define:
                instr.define_dict[item] = {instr.ea}
                if item.startswith("e") and item.endswith("x"):
                    item16bit = item[1:]
                    item8high = item[1]+'h'
                    item8low = item[1]+'l'
                    instr.define_dict[item16bit] = {instr.ea}
                    instr.define_dict[item8high] = {instr.ea}
                    instr.define_dict[item8low] = {instr.ea}
                    
            # update define_dict at next instruction
            for next_ea in instr.next_ea:
                for index, addr in instr.define_dict.items():
                # update define_dict at next_ea
                    if index in self.node_arr[next_ea].define_dict:
                        self.node_arr[next_ea].define_dict[index].update(addr)
                    else:
                        self.node_arr[next_ea].define_dict[index] = addr
                        # update stack at next_ea
                        self.node_arr[next_ea].stack = (instr.stack)
                            
    __set_node_array = set_node_array
                        
    def append_nodes(self):
        for key, value in self.node_dict.items():
            if isinstance(key, str): # 'START'
                self.node_buffer += '    n{}     [label = \"{}; DD: '.format(value[0], key)
            else: # Memory address
                self.node_buffer += '    n{}     [label = \"{}; DD: '.format(value[0], hex(key))
            
            temp = set()
            if (value[1] != set()):
                for item in value[1]:
                    if isinstance(item, str):
                        temp.add(item) # 'START'
                    else:
                        temp.add(hex(item)) # Memory address
                    self.path_buffer += '    n{} -> n{};\n'.format(value[0], self.node_dict[item][0])
                    
            self.node_buffer += ', '.join(temp)
            self.node_buffer += '\"];\n'
    __append_nodes = append_nodes